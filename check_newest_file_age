#! /bin/sh
#
# Newest file in a directory plugin for Nagios.
# Written by Chad Phillips (chad@apartmentlines.com)
# Last Modified: 2016-04-21

PROGPATH=`dirname $0`

. $PROGPATH/utils.sh

print_usage() {
    echo "
Usage: check_newest_file_age --dirs | -d <directories> [-f <file_pattern>] [-w <max_age>] [-c <max_age>] [-W] [-C] [-t <time_unit>] [-V] [--check-dirs] [--base-dir <directory>]
Usage: check_newest_file_age --help | -h

Description:

This plugin pulls the most recently created file in each specified directory,
and checks it's created time against the current time.  If the maximum age of
the file is exceeded, a warning/critical message is returned as appropriate.

This is useful for examining backup directories for freshness.

Tested to work on Linux/FreeBSD/OS X.

The following arguments are accepted:

  --dirs | -d     A space separated list of directories to examine.  Each
                  directory will be checked for the newest created file in that
                  directory.

  -f              (Optional) Filename pattern with wildcard ? * and [0-9][a-z]
                  It's used for select specific files.  Defaults is '*'.

  -w              (Optional) Generate a warning message if the last created
                  file is older than this value.  Defaults to 26 hours.
                  To disable this treshold, set -w '-'

  -c              (Optional) Generate a critical message if the last created
                  file is older than this value.  Defaults to 52 hours.
                  To disable this treshold, set -c '-'

  -W              (Optional) If set, a warning message will be returned if the
                  specified directory doesn't exist, or there are no checkable
                  files in the specified directory.

  -C              (Optional) If set, a critical message will be returned if the
                  specified directory doesn't exist, or there are no checkable
                  files in the specified directory.

  -t              (Optional) The time unit used for the -w and -c values.  Must
                  be one of: seconds, minutes, hours, days.  Defaults to hours.

  -V              (Optional) Output verbose information about all checked
                  directories.  Default is only to print verbose information
                  for directories with non-OK states.

  --check-dirs    (Optional) If set, directories inside the specified directory
                  will also be checked for their creation time. Note that this
                  check is not recursive.  Without this option, only real files
                  inside the specified directory will be checked.

  --base-dir      (Optional) If set, this path will be prepended to all
                  checked directories.

  --help | -h     Print this help and exit.

Examples:

Generate a warning if the newest file in /backups is more than 26 hours old,
and a critical if it's more than 52 hours old...

  check_newest_file_age -d \"/backups\"

Generate a warning if the newest file in /backups/bill or /backups/dave is more
than one week old, or a critical if it's more than two weeks old...

  check_newest_file_age -d \"/backups/bill /backups/dave\" -w 7 -c 14 -t days

Caveats:

Although multiple directories can be specified, only one set of
warning/critical times can be supplied.

Linux doesn't seem to have an easy way to check file/directory creation time,
so file/directory last modification time is used instead.
"
}

print_help() {
    print_usage
    echo "Newest file in a directory plugin for Nagios."
    echo ""
}

# Sets the exit status for the plugin.  This is done in such a way that the
# status can only go in one direction: OK -> WARNING -> CRITICAL.
set_exit_status() {
  new_status=$1
  # Nothing needs to be done if the state is already critical, so exclude
  # that case.
  case $exitstatus
  in
    $STATE_WARNING)
      # Only upgrade from warning to critical.
      if [ "$new_status" = "$STATE_CRITICAL" ]; then
        exitstatus=$new_status;
      fi
    ;;
    $STATE_OK)
      # Always update state if current state is OK.
      exitstatus=$new_status;
    ;;
  esac
}

# Make sure the correct number of command line
# arguments have been supplied
if [ $# -lt 1 ]; then
    print_usage
    exit $STATE_UNKNOWN
fi

# Defaults.
exitstatus=$STATE_OK
warning=26
critical=52
time_unit='hours'
st_ctime=0
verbose=0
on_empty=$STATE_OK
check_dirs=0
base_dir=''
f_pattern='*'              # Default : Search all files
find_opts='-maxdepth 1'    # Default : Non-recursive search

# Grab the command line arguments.
while test -n "$1"; do
    case "$1" in
        --help)
            print_help
            exit $STATE_OK
            ;;
        -h)
            print_help
            exit $STATE_OK
            ;;
        --dirs)
            dirs=$2
            shift
            ;;
        -d)
            dirs=$2
            shift
            ;;
        -w)
            warning=$2
            shift
            ;;
        -c)
            critical=$2
            shift
            ;;
        -W)
            on_empty=$STATE_WARNING
            ;;
        -C)
            on_empty=$STATE_CRITICAL
            ;;
        -t)
            time_unit=$2
            shift
            ;;
        -V)
            verbose=1
            ;;
        --check-dirs)
            check_dirs=1
            # We want a recursive search (clear default value)
            find_opts=''
            ;;
        --base-dir)
            base_dir="$2/"
            shift
            ;;
        -x)
            exitstatus=$2
            shift
            ;;
        --exitstatus)
            exitstatus=$2
            shift
            ;;
        -f)
            f_pattern=${2}
            shift
            ;;
        *)
            echo "Unknown argument: $1"
            print_usage
            exit $STATE_UNKNOWN
            ;;
    esac
    shift
done

if [ ! "$dirs" ]; then
  echo "No directories provided."
  exit $STATE_UNKNOWN
fi

if [ `echo "$warning" | grep [^0-9\-]` ] || [ ! "$warning" ]; then
  echo "Warning value must be a number or dash (-)."
  exit $STATE_UNKNOWN
fi

if [ `echo "$critical" | grep [^0-9\-]` ] || [ ! "$critical" ]; then
  echo "Critical value must be a number or dash (-)."
  exit $STATE_UNKNOWN
fi

if [ ! `echo "$time_unit" | grep "seconds\|minutes\|hours\|days"` ]; then
  echo "Time unit must be one of: seconds, minutes, hours, days."
  exit $STATE_UNKNOWN
fi

if [ ${critical} != "-" ] && [ ${warning} != "-" ]; then
  if [ "$warning" -ge "$critical" ]; then
    echo "Critical time must be greater than warning time."
    exit $STATE_UNKNOWN
  fi
fi

case $time_unit
in
  days)
    multiplier=86400;
    abbreviation="days";
  ;;
  hours)
    multiplier=3600;
    abbreviation="hrs";
  ;;
  minutes)
    multiplier=60;
    abbreviation="mins";
  ;;
  *)
    multiplier=1
    abbreviation="secs";
  ;;
esac

# Starting values.
DIR_COUNT=0
OK_FILE_COUNT=0
OUTPUT=
CURRENT_TIME=`date +%s`
OS_DISTRO=`uname -s`

# Convert threshold time in seconds
if [ ${warning} != "-" ]; then
  MAX_WARN_AGE=$(($warning * $multiplier))
else
  MAX_WARN_AGE=0     # To avoid arithmetic error
fi

if [ ${critical} != "-" ]; then
  MAX_CRIT_AGE=$(($critical * $multiplier))
else
  MAX_CRIT_AGE=0     # To avoid arithmetic error
fi

# Loop through each provided directory.
for dir in $dirs
do
  DIR_COUNT=$(($DIR_COUNT + 1))

  # Check if dir exists.
  full_path="${base_dir}${dir}"
  if [ -d "$full_path" ]; then
    # Find the most recent file in a directory
    # find / stat doesn't work the same on Linux/Solaris vs. FreeBSD/Darwin, so make adjustments here.
    if [ "$OS_DISTRO" = "Linux" ] || [ "$OS_DISTRO" = "SunOS" ]; then
      # Linux / Oracle Solaris
      file_list=`find ${full_path} ${find_opts} -type f -name "${f_pattern}" -printf '%T@ %p (%Tc)\n' | sort -rn | head -1`
#echo $file_list
      st_ctime=`echo ${file_list} | cut -d "." -f1`
      filename=`echo ${file_list} | cut -d " " -f2-`
    else
      # FreeBSD/Darwin
      file_list=`find ${full_path} ${find_opts} -type f -name "${f_pattern}" -print0 | xargs -0 stat -f "%m %N" | sort -rn | head -1`
      st_ctime=`echo ${file_list} | cut -d "." -f1`
      filename=`echo ${file_list} | cut -d " " -f2-`
    fi

    # Check here to see if any files got tested in the directory.
    if [ "${file_list}" ]; then
      # Case : Files found

      # Force type into integer
      st_ctime=`printf "%i" ${st_ctime}`

      # Compare with treshold Warning / Critical
      FILE_AGE=$(( $CURRENT_TIME - ${st_ctime} ))
      FILE_AGE_UNITS=$(( $FILE_AGE / $multiplier ))

      if  [ ${critical} != "-" ] && [ $FILE_AGE -gt $MAX_CRIT_AGE ]; then
        OUTPUT="$OUTPUT ${dir}${f_pattern}: ${FILE_AGE_UNITS}${abbreviation}"
        set_exit_status $STATE_CRITICAL
      elif  [ ${warning} != "-" ] && [ $FILE_AGE -gt $MAX_WARN_AGE ]; then
        OUTPUT="$OUTPUT ${dir}${f_pattern}: ${FILE_AGE_UNITS}${abbreviation}"
        set_exit_status $STATE_WARNING
      else
        OK_FILE_COUNT=$(($OK_FILE_COUNT + 1))
        if [ "$verbose" ]; then
          OUTPUT="$OUTPUT ${dir}${f_pattern}: ${FILE_AGE_UNITS}${abbreviation}"
        fi
      fi
    else
      # Case : No files

      set_exit_status $on_empty
      OUTPUT="$OUTPUT ${dir}${f_pattern}: No files"
      # If empty is an OK state, then increment the ok file count.
      if [ "$on_empty" = "$STATE_OK" ]; then
        OK_FILE_COUNT=$(($OK_FILE_COUNT + 1))
      fi
    fi

  else
    set_exit_status $on_empty
    OUTPUT="$OUTPUT ${dir}: Does not exist"
  fi
done

case $exitstatus
in
  $STATE_CRITICAL)
    exit_message="CRITICAL";
  ;;
  $STATE_WARNING)
    exit_message="WARNING";
  ;;
  $STATE_OK)
    exit_message="OK";
  ;;
  *)
    exitstatus=$STATE_UNKNOWN;
    exit_message="UNKNOWN";
  ;;
esac

exit_message="${exit_message}: ${OK_FILE_COUNT}/${DIR_COUNT}"

if [ "$OUTPUT" ]; then
  exit_message="${exit_message} --${OUTPUT}"
fi

echo "$exit_message"
exit $exitstatus
